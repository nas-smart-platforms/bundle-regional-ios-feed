// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.2.4 (swiftlang-1103.0.32.9 clang-1103.0.32.53)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name API
import Combine
import Foundation
import JWTDecode
import Swift
import UIKit
import Valet
import os.log
import os
public protocol MessageHandling {
  func messageList(for group: API.Group) -> Combine.AnyPublisher<[API.Message], API.APIServiceError>
  func send(_ message: API.Message, in group: API.Group) -> Combine.AnyPublisher<API.MessageSendResponse, API.APIServiceError>
}
extension API : API.MessageHandling {
  public func messageList(for group: API.Group) -> Combine.AnyPublisher<[API.Message], API.APIServiceError>
  public func send(_ message: API.Message, in group: API.Group) -> Combine.AnyPublisher<API.MessageSendResponse, API.APIServiceError>
}
public class API {
  public static var openISO8601DateFormatter: API.OpenISO8601DateFormatter
  public enum Version : Swift.String {
    case v1, v2
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public init()
  @objc deinit
}
public enum APIServiceError : Swift.Error, Swift.CustomStringConvertible {
  case generalFuckup(message: Swift.String)
  case invalidURL(url: Swift.String)
  case decode(underlyingError: Swift.Error)
  case statusCode(code: Swift.Int, responseBody: Swift.String?)
  case unkown(underlyingError: Swift.Error?)
  case authenticationRequired
  public var description: Swift.String {
    get
  }
  public var localizedDescription: Swift.String {
    get
  }
}
extension APIServiceError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
  public var recoverySuggestion: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Networking {
  public static var hostURL: Foundation.URL
  public static var sessionConfiguration: Foundation.URLSessionConfiguration
  final public var session: Foundation.URLSession {
    get
    set
  }
  @objc deinit
}
public enum StringSearch : Swift.Encodable {
  case eq(value: Swift.String, type: Swift.String)
  case text(value: Swift.String, type: Swift.String)
  public func encode(to encoder: Swift.Encoder) throws
}
public struct UserProfileSearchRoot : Swift.Encodable {
  public let user: API.UserSearchRequest
  public func encode(to encoder: Swift.Encoder) throws
}
public struct UserSearchRequest : Swift.Encodable {
  public let id: API.StringSearch?
  public func encode(to encoder: Swift.Encoder) throws
}
public struct UserUpdateRequest : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
public struct UserRegisterRequest : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
public struct UserProfileFetchResponse : Swift.Decodable {
  public let data: [API.UserProfile]
  public init(from decoder: Swift.Decoder) throws
}
public enum UserRouter : API.Router {
  case fetch(parameters: API.UserProfileSearchRoot)
  case update(parameters: API.UserUpdateRequest)
  case register(paramters: API.UserRegisterRequest)
  public var method: API.HttpMethod {
    get
  }
  public var basePath: Swift.String {
    get
  }
  public var path: Swift.String {
    get
  }
  public var url: Foundation.URL {
    get
  }
  public func encodeHttpBody(request: inout Foundation.URLRequest)
}
public protocol UserProfileHandling {
  func searchUserProfile(with params: API.UserProfileSearchRoot) -> Combine.AnyPublisher<API.UserProfileFetchResponse, API.APIServiceError>
  func fetchUserProfile(for userId: Foundation.UUID, completion: @escaping (Swift.Result<API.UserProfile, API.APIServiceError>) -> Swift.Void)
}
extension API : API.UserProfileHandling {
  public func fetchUserProfile(for userId: Foundation.UUID, completion: @escaping (Swift.Result<API.UserProfile, API.APIServiceError>) -> Swift.Void)
  public func searchUserProfile(with params: API.UserProfileSearchRoot) -> Combine.AnyPublisher<API.UserProfileFetchResponse, API.APIServiceError>
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class OpenISO8601DateFormatter : Foundation.DateFormatter {
  @objc override dynamic public func date(from string: Swift.String) -> Foundation.Date?
  @objc deinit
}
public enum FileType : Swift.String {
  case original
  case large
  case medium
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum StorageTopic {
  case userAvatar(userId: Foundation.UUID)
  case groupImage(groupId: Foundation.UUID)
  case contentFile(groupId: Foundation.UUID)
}
public struct FileUploadResponse {
  public let itemId: Foundation.UUID
}
public struct ExpirableURL : Swift.Decodable {
  public let itemId: Foundation.UUID?
  public let path: Foundation.URL
  public let expiration: Swift.Int
  public init(from decoder: Swift.Decoder) throws
}
public struct FileDownloadPreparationResponse : Swift.Decodable {
  public let id: Foundation.UUID
  public let status: Swift.String
  public let sha1: Swift.String?
  public let mimetype: Swift.String?
  public let files: [API.FileReference]?
  public init(from decoder: Swift.Decoder) throws
}
public struct FileReference : Swift.Decodable {
  public let id: Foundation.UUID?
  public let filetype: Swift.String
  public let url: API.ExpirableURL
  public init(from decoder: Swift.Decoder) throws
}
public protocol StorageHandling {
  func upload(data: Foundation.Data, context: API.StorageTopic, fileName filename: Swift.String) -> Combine.AnyPublisher<API.FileUploadResponse, API.APIServiceError>
  func fetchDownloadURLs(ids: [Foundation.UUID], fileType: API.FileType) -> Combine.AnyPublisher<[API.FileReference], API.APIServiceError>
  func downloadFile(reference: API.FileReference) -> Combine.AnyPublisher<Foundation.Data, API.APIServiceError>
}
extension API : API.StorageHandling {
  public func upload(data: Foundation.Data, context: API.StorageTopic, fileName filename: Swift.String = UUID().uuidString) -> Combine.AnyPublisher<API.FileUploadResponse, API.APIServiceError>
  public func fetchDownloadURLs(ids: [Foundation.UUID], fileType: API.FileType) -> Combine.AnyPublisher<[API.FileReference], API.APIServiceError>
  public func downloadFile(reference: API.FileReference) -> Combine.AnyPublisher<Foundation.Data, API.APIServiceError>
}
public enum HttpMethod : Swift.String, Swift.CaseIterable {
  case GET
  case HEAD
  case POST
  case PUT
  case PATCH
  case DELETE
  case OPTIONS
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [API.HttpMethod]
  public static var allCases: [API.HttpMethod] {
    get
  }
}
public protocol Router {
  var method: API.HttpMethod { get }
  var url: Foundation.URL { get }
  var basePath: Swift.String { get }
  var path: Swift.String { get }
  func urlRequest() throws -> Foundation.URLRequest
  func encodeHttpBody(request: inout Foundation.URLRequest)
}
extension Router {
  public func urlRequest() -> Foundation.URLRequest
}
public protocol Authentication {
  var currentUser: API.User? { get }
  func login(username: Swift.String?, password: Swift.String?) -> Combine.AnyPublisher<API.AuthenticationResponse, API.APIServiceError>
}
public struct User : Swift.Codable, Swift.CustomStringConvertible, Swift.Equatable {
  public let id: Foundation.UUID
  public let name: Swift.String?
  public var accessToken: API.Token
  public var refreshToken: API.Token
  public var description: Swift.String {
    get
  }
  public static func == (lhs: API.User, rhs: API.User) -> Swift.Bool
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct Token : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct AuthenticationResponse : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension API : API.Authentication {
  public var currentUser: API.User? {
    get
  }
  public func login(username: Swift.String? = nil, password: Swift.String? = nil) -> Combine.AnyPublisher<API.AuthenticationResponse, API.APIServiceError>
}
public class Authenticator {
  public static var currentUser: API.User? {
    get
  }
  public init()
  public func invalidateOutdated()
  public func logout()
  public func login(username: Swift.String? = nil, password: Swift.String? = nil, completion: @escaping (Swift.Result<API.User, API.APIServiceError>) -> ())
  @objc deinit
}
public protocol MessagePart {
}
public enum MessageType : Swift.String, Swift.CaseIterable, Swift.Codable {
  case text
  case image
  case appointment
  case voucher
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [API.MessageType]
  public static var allCases: [API.MessageType] {
    get
  }
}
public enum AnyMessage : Swift.Codable {
  case textMessage(API.MessageType, Swift.Int, Swift.String)
  case imageMessage(API.MessageType, Swift.Int, Foundation.UUID)
  case appointmentMessage(API.MessageType, Swift.Int, Foundation.Date, Foundation.Date, Swift.Bool)
  case voucherMessage(API.MessageType, Swift.Int, Swift.String, Swift.String)
  case noMessage
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct Message : Swift.Codable, Swift.Equatable {
  public let id: Foundation.UUID
  public let parts: [API.MessagePart]
  public let creatorID: Foundation.UUID
  public let createdAt: Foundation.Date
  public let groupID: Foundation.UUID
  public struct Text : Swift.Codable {
    public let text: Swift.String
    public init(text: Swift.String)
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
  public struct Image : Swift.Codable {
    public let imageID: Foundation.UUID
    public init(imageID: Foundation.UUID)
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
  public struct Appointment : Swift.Codable {
    public let startDate: Foundation.Date
    public let endDate: Foundation.Date
    public let isAllDay: Swift.Bool
    public init(startDate: Foundation.Date, endDate: Foundation.Date, isAllDay: Swift.Bool)
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
  public struct Voucher : Swift.Codable {
    public let vouchertype: Swift.String
    public let vouchercode: Swift.String
    public init(subType: Swift.String, code: Swift.String)
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
  public init(creatorID: Foundation.UUID, groupID: Foundation.UUID, parts: [API.MessagePart])
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (lhs: API.Message, rhs: API.Message) -> Swift.Bool
}
public struct MessageQuery : Swift.Codable {
  public let id: Foundation.UUID
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct MessageQuerySlice : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct MessageFetchRequest : Swift.Codable {
  public let group: API.MessageQuery
  public let content: API.MessageQuerySlice
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct MessageSendRequest : Swift.Encodable {
  public let groupID: Foundation.UUID
  public let cloakID: Foundation.UUID?
  public let parts: [API.MessagePart]
  public func encode(to encoder: Swift.Encoder) throws
}
public struct MessageSendResponse : Swift.Codable {
  public let id: Foundation.UUID
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum GroupRouter : API.Router {
  public func encodeHttpBody(request: inout Foundation.URLRequest)
  case fetch(parameters: API.GroupRequest)
  case create(parameters: API.GroupCreationRequest)
  case join(parameters: API.JoinGroupRequest)
  case leave(parameters: API.LeaveGroupRequest)
  public var method: API.HttpMethod {
    get
  }
  public var basePath: Swift.String {
    get
  }
  public var path: Swift.String {
    get
  }
  public var url: Foundation.URL {
    get
  }
  public func urlRequest() -> Foundation.URLRequest
}
public protocol GroupHandling {
  func groupPublisher(with params: API.GroupRequest) -> Combine.AnyPublisher<API.GroupFetchResponse, API.APIServiceError>
  func createGroup(with params: API.GroupCreationRequest) -> Combine.AnyPublisher<API.Group, API.APIServiceError>
  func joinGroup(with groupID: Foundation.UUID) -> Combine.AnyPublisher<Swift.Bool, API.APIServiceError>
  func leaveGroup(with groupID: Foundation.UUID) -> Combine.AnyPublisher<Swift.Bool, API.APIServiceError>
}
extension API : API.GroupHandling {
  public func groupPublisher(with params: API.GroupRequest) -> Combine.AnyPublisher<API.GroupFetchResponse, API.APIServiceError>
  public func createGroup(with params: API.GroupCreationRequest) -> Combine.AnyPublisher<API.Group, API.APIServiceError>
  public func joinGroup(with groupID: Foundation.UUID) -> Combine.AnyPublisher<Swift.Bool, API.APIServiceError>
  public func leaveGroup(with groupID: Foundation.UUID) -> Combine.AnyPublisher<Swift.Bool, API.APIServiceError>
}
public struct GroupRequest : Swift.Codable {
  public let query: API.GroupQuery
  public let slice: API.Slice?
  public let projection: API.Projection?
  public init(query: API.GroupQuery?, slice: API.Slice?, projection: API.Projection?)
  public init()
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct GroupQuery : Swift.Codable {
  public let id: Foundation.UUID?
  public let types: [API.GroupType]?
  public let states: [API.GroupState]?
  public init(id: Foundation.UUID? = nil, types: [API.GroupType]? = nil, states: [API.GroupState]? = nil)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct GroupFetchResponse : Swift.Codable {
  public let data: [API.Group]
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct GroupCreationRequest : Swift.Codable {
  public let name: Swift.String
  public let type: API.GroupType
  public let state: API.GroupState
  public let userId: Swift.String
  public init(name: Swift.String, type: API.GroupType, state: API.GroupState, userId: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct GroupCreationResponse : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct JoinGroupRequest : Swift.Encodable {
  public let groupid: Foundation.UUID
  public func encode(to encoder: Swift.Encoder) throws
}
public struct LeaveGroupRequest : Swift.Encodable {
  public let groupid: Foundation.UUID
  public func encode(to encoder: Swift.Encoder) throws
}
public struct GroupJoinResponse : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
public struct GroupLeaveResponse : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
public struct Group : Swift.Codable, Swift.Equatable {
  public struct LastContentMessage {
    public let groupId: Foundation.UUID
    public let id: Foundation.UUID
    public let creatorId: Foundation.UUID
    public let created: Foundation.Date
  }
  public let id: Foundation.UUID
  public let name: Swift.String
  public let description: Swift.String?
  public let ismember: Swift.Bool?
  public let imageid: Foundation.UUID?
  public let type: API.GroupType
  public let state: API.GroupState
  public let lastcontent: API.Message?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: API.Group, b: API.Group) -> Swift.Bool
}
public enum GroupType : Swift.String, Swift.CaseIterable, Swift.Codable {
  case broadcast
  case service
  case fgi
  case notes
  case feedback
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [API.GroupType]
  public static var allCases: [API.GroupType] {
    get
  }
}
public enum GroupState : Swift.String, Swift.CaseIterable, Swift.Codable {
  case new
  case inprogress
  case closed
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [API.GroupState]
  public static var allCases: [API.GroupState] {
    get
  }
}
public struct Slice : Swift.Codable {
  public let offset: Swift.UInt
  public let limit: Swift.UInt
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum Projection : Swift.String, Swift.CaseIterable, Swift.Codable {
  case all
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [API.Projection]
  public static var allCases: [API.Projection] {
    get
  }
}
public struct UserProfile : Swift.Decodable {
  public let id: Foundation.UUID
  public let state: API.UserProfileState
  public let email: Swift.String
  public let gender: API.Gender?
  public let title: API.AcedemicTitleEnum?
  public let firstname: Swift.String?
  public let lastname: Swift.String?
  public let birthdate: Foundation.Date?
  public let imageid: Foundation.UUID?
  public init(from decoder: Swift.Decoder) throws
}
public enum PostalType : Swift.String, Swift.Decodable {
  case registered, billing, shipping
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum UserProfileState : Swift.String, Swift.Decodable {
  case anonymous, normal, deleted
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum Gender : Swift.String, Swift.Decodable {
  case male, female, diverse, notspecified, null
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum AcedemicTitleEnum : Swift.String, Swift.Decodable {
  case dr, prof, null
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
extension API.API.Version : Swift.Equatable {}
extension API.API.Version : Swift.Hashable {}
extension API.API.Version : Swift.RawRepresentable {}
extension API.FileType : Swift.Equatable {}
extension API.FileType : Swift.Hashable {}
extension API.FileType : Swift.RawRepresentable {}
extension API.HttpMethod : Swift.Equatable {}
extension API.HttpMethod : Swift.Hashable {}
extension API.HttpMethod : Swift.RawRepresentable {}
extension API.MessageType : Swift.Equatable {}
extension API.MessageType : Swift.Hashable {}
extension API.MessageType : Swift.RawRepresentable {}
extension API.Message.Text : API.MessagePart {}
extension API.Message.Image : API.MessagePart {}
extension API.Message.Appointment : API.MessagePart {}
extension API.Message.Voucher : API.MessagePart {}
extension API.GroupType : Swift.Equatable {}
extension API.GroupType : Swift.Hashable {}
extension API.GroupType : Swift.RawRepresentable {}
extension API.GroupState : Swift.Equatable {}
extension API.GroupState : Swift.Hashable {}
extension API.GroupState : Swift.RawRepresentable {}
extension API.Projection : Swift.Equatable {}
extension API.Projection : Swift.Hashable {}
extension API.Projection : Swift.RawRepresentable {}
extension API.PostalType : Swift.Equatable {}
extension API.PostalType : Swift.Hashable {}
extension API.PostalType : Swift.RawRepresentable {}
extension API.UserProfileState : Swift.Equatable {}
extension API.UserProfileState : Swift.Hashable {}
extension API.UserProfileState : Swift.RawRepresentable {}
extension API.Gender : Swift.Equatable {}
extension API.Gender : Swift.Hashable {}
extension API.Gender : Swift.RawRepresentable {}
extension API.AcedemicTitleEnum : Swift.Equatable {}
extension API.AcedemicTitleEnum : Swift.Hashable {}
extension API.AcedemicTitleEnum : Swift.RawRepresentable {}
